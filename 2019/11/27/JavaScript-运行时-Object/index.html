<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="JavaScript Object">
<meta name="keywords" content="前端,JavaScript,Object">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript Object">
<meta property="og:url" content="http://yoursite.com/2019/11/27/JavaScript-运行时-Object/index.html">
<meta property="og:site_name" content="FINO ALLA FINE">
<meta property="og:description" content="JavaScript Object">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/JavaScript/proto.png">
<meta property="og:image" content="http://yoursite.com/images/JavaScript/prototype.jpg">
<meta property="og:image" content="http://yoursite.com/images/JavaScript/simple.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaScript/class-prototype.png">
<meta property="og:image" content="http://yoursite.com/images/JavaScript/built-in-object.png">
<meta property="og:updated_time" content="2019-11-27T13:35:03.315Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript Object">
<meta name="twitter:description" content="JavaScript Object">
<meta name="twitter:image" content="http://yoursite.com/images/JavaScript/proto.png">
  <link rel="canonical" href="http://yoursite.com/2019/11/27/JavaScript-运行时-Object/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JavaScript Object | FINO ALLA FINE</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FINO ALLA FINE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/JavaScript-运行时-Object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frank Hu">
      <meta itemprop="description" content="Developer, Juventino">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FINO ALLA FINE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">JavaScript Object

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-27 11:21:06 / 修改时间：21:35:03" itemprop="dateCreated datePublished" datetime="2019-11-27T11:21:06+08:00">2019-11-27</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            <div class="post-description">JavaScript Object</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>JavaScript 是面向对象的语言，<strong>使用了原型来描述语言中的对象</strong>。Java/C++ <strong>使用类来描述语言中的对象</strong>。然而很不幸，因为一些公司政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来更像 Java”，这也给有了 Java 基础的人士一些误导。</p>
<p>其实理解面向对象应该从运行时角度去理解，因为任何语言代码都绕不开运行时的对象模型。从运行时角度来说，类的概念是被弱化的。</p>
<p>一般意义上，对象的特点包括：</p>
<ul>
<li>对象具有唯一标识性，一般来说是内存地址：即使完全相同的两个对象，也并非同一个对象。</li>
<li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li>
<li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li>
</ul>
<p>在 JavaScript 中，除了将一般对象的特点涵盖进来外， <strong>JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力</strong>。</p>
<p>一个对象的典型定义方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  d: <span class="number">1</span>,</span><br><span class="line">  f() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.d); <span class="comment">// 函数是一种特殊 Object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，JavaScript 对象的运行时就是一个“属性的集合”，状态和行为都用“属性”表示，属性分为<code>数据属性</code>和<code>访问器属性</code>。属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。属性以字符串或者 Symbol 为 key，以数据属性特征或者访问器属性特征为 value。</p>
<p>我们以上面的对象 o 为例，你可以想象一下 <code>d</code> 是 key，<code>{writable:true,value:1,configurable:true,enumerable:true}</code> 是 value。</p>
<h2 id="数据属性和访问器属性-getter-setter"><a href="#数据属性和访问器属性-getter-setter" class="headerlink" title="数据属性和访问器属性(getter/setter)"></a>数据属性和访问器属性(getter/setter)</h2><p>JavaScript 的属性分为数据属性和访问器属性。</p>
<p>数据属性主要用于描述属性的值。访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p>
<p>为了更好得描述属性，引入了多种特征来描述属性。</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性的特征包括：</p>
<ul>
<li><code>[[value]]</code>：就是属性的值。</li>
<li><code>[[writable]]</code>：决定属性能否被赋值。默认为 true。</li>
<li><code>[[enumerable]]</code>：决定 for in 能否枚举该属性。默认为 true。</li>
<li><code>[[configurable]]</code>：决定该属性能否能被删除或者改变特征。默认为 true。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种定义数据属性方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种定义数据属性方法</span></span><br><span class="line">o.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种定义数据属性方法</span></span><br><span class="line">o.[<span class="string">"name"</span>] = <span class="string">"frank"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到数据属性特征</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"a"</span>); <span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"b"</span>); <span class="comment">// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义/修改数据属性特征。</span></span><br><span class="line"><span class="comment">// 第四种定义数据属性方法。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"c"</span>, &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// 使 c 属性无法被重写</span></span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"a"</span>); <span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"c"</span>); <span class="comment">// &#123;value: 3, writable: false, enumerable: false, configurable: true&#125;</span></span><br><span class="line">o.c = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性分为 getter 属性和 setter 属性。访问器属性跟数据属性不同，每次访问属性都会执行 getter 或 setter。</p>
<p>访问器属性的特征包括：</p>
<ul>
<li><code>[[getter]]</code>：函数或 undefined，在取属性值时被调用。</li>
<li><code>[[setter]]</code>：函数或 undefined，在设置属性值时被调用。</li>
<li><code>[[enumerable]]</code>：决定 for in 能否枚举该属性。</li>
<li><code>[[configurable]]</code>：决定该属性能否被删除或者改变特征。</li>
</ul>
<p>访问器属性的定义方法包括：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种定义方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">7</span>,</span><br><span class="line">  <span class="keyword">get</span> b() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> c(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = x / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 8. Runs the getter</span></span><br><span class="line">o.c = <span class="number">50</span>; <span class="comment">// Runs the setter</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种定义方法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"b"</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = x / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.b = <span class="number">10</span>; <span class="comment">// Runs the setter, which assigns 10 / 2 (5) to the 'a' property</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><strong>JavaScript 实现面向对象的方式是使用原型</strong>。“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。</p>
<p>Java 等语言实现面向对象的方式是使用类。“基于类”的编程提倡使用一个关注类和类之间关系的开发模型。在这类语言中，<strong>总是先有类，再从类去实例化一个对象</strong>。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。</p>
<p>基于原型的面向对象系统<strong>通过“复制”的方式来创建新对象</strong>。主要有两种实现思路：</p>
<ul>
<li>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用。<strong>JavaScript 选择了这种实现方式</strong>。</li>
<li>另一个是切实地复制对象，从此两个对象再无关联。</li>
</ul>
<p>JavaScript 原型系统的原理：</p>
<p><img src="/images/JavaScript/proto.png" alt="proto"></p>
<ul>
<li>所有对象都有私有字段 <code>[[prototype]]</code>，就是对象的原型。</li>
<li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li>
</ul>
<h3 id="prototype-VS-proto-VS-prototype"><a href="#prototype-VS-proto-VS-prototype" class="headerlink" title="[[prototype]] VS __proto__ VS prototype"></a><code>[[prototype]]</code> VS <code>__proto__</code> VS <code>prototype</code></h3><p><img src="/images/JavaScript/prototype.jpg" alt="prototype"></p>
<ul>
<li><code>[[prototype]]</code> 是所有对象都有的<strong>私有字段</strong>，也就是该对象的原型。<code>b.[[prototype]]</code> 就是指向 b 对象的原型。但是，<code>[[prototype]]</code> 是对象的私有字段，不能直接使用<code>b.[[prototype]]</code>来获得该对象的原型。如上图中，f1 对象的 <code>[[prototype]]</code> 指向 <code>Foo.prototype</code>。</li>
<li><code>__proto__</code> 是已经过时的 API, 在很多浏览器中，使用 <code>__proto__</code> 表示 <code>[[prototype]]</code>。<code>b.__proto__</code> 用来得到 b 对象的原型。现在的获得 b 对象原型的 API 是 <code>Object.getPrototypeOf(b)</code></li>
<li><code>prototype</code> 是只有构造器(constructor functions)才有的<strong>私有属性</strong>。具体可参考上图所示的构造器 Foo。</li>
</ul>
<h3 id="操作对象原型的方法"><a href="#操作对象原型的方法" class="headerlink" title="操作对象原型的方法"></a>操作对象原型的方法</h3><p>三种指定对象原型的方法：</p>
<ul>
<li><code>Object.create</code></li>
<li><code>Object.setPrototypeOf</code></li>
<li><code>new 操作符</code></li>
</ul>
<p>一种获得对象原型的方法：</p>
<ul>
<li><p><code>Object.getPrototypeOf</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === <span class="built_in">Object</span>.prototype; <span class="comment">// 常用的获得对象的原型的方法</span></span><br><span class="line">a.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a><code>Object.create</code></h4><p><code>Object.create</code> 是常用的创建对象并指定该对象原型的方法。</p>
<p><img src="/images/JavaScript/simple.PNG" alt="simple"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherObject = <span class="built_in">Object</span>.create(myObject);</span><br><span class="line">anotherObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h4><p>new 操作符是另一个经常看到的用于创建对象的方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">// var a = new Foo; // new后面可有可无()，最好使用有()的写法。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype; <span class="comment">// true</span></span><br><span class="line">a.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当普通函数调用时前面加了 new，该函数成为<strong>构造器</strong>。<code>new 构造器()</code> 要和原型一起理解。</p>
<p>new 主要用于新建一个对象，新对象的原型就是构造器的 prototype 属性。<code>new 构造器()</code>时发生了：</p>
<ol>
<li>以构造器的 prototype 私有属性为原型，创建新对象</li>
<li>将 this 和调用参数传给构造器并执行</li>
<li>如果构造器返回的是对象，则返回；否则返回第一步创建的对象</li>
</ol>
<p>通过分析 new 发生的过程，可以知道发现有两种给对象添加属性的方法：</p>
<ol>
<li><p>构造器中添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.p1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.p2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.p1);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> c1();</span><br><span class="line">o1.p2(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器的 prototype 属性上添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">c2.prototype.p1 = <span class="number">1</span>;</span><br><span class="line">c2.prototype.p2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.p1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> c2();</span><br><span class="line">o2.p2(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="ES6-中引入的-class，使“类”的思想设计代码更清晰"><a href="#ES6-中引入的-class，使“类”的思想设计代码更清晰" class="headerlink" title="ES6 中引入的 class，使“类”的思想设计代码更清晰"></a>ES6 中引入的 class，使“类”的思想设计代码更清晰</h2><p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 <code>[[class]]</code>，语言标准为内置类型诸如 Number、String、Date 等指定了 <code>[[class]]</code> 属性，以表示它们的类。语言使用者唯一可以访问 <code>[[class]]</code> 属性的方式是 <code>Object.prototype.toString</code>。</p>
<p>在 ES5 开始，<code>[[class]]</code> 私有属性被 <code>Symbol.toStringTag</code> 代替，<code>Object.prototype.toString</code> 的意义从命名上不再跟 class 相关。我们甚至可以自定义 <code>Object.prototype.toString</code> 的行为，以下代码展示了使用 <code>Symbol.toStringTag</code> 来自定义 <code>Object.prototype.toString</code> 的行为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">"MyObject"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o + <span class="string">""</span>); <span class="comment">// [object MyObject]</span></span><br></pre></td></tr></table></figure>

<p>ES6 中加入了新特性 class，使用 new 跟 function 搭配来模拟 Java 的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，都推荐使用 ES6 的语法来定义“类”，而令 function 回归原本的函数语义。也就是说，<strong>当使用“类”的思想来设计代码时，推荐放弃使用 ES6 之前使用的<code>new 构造器()</code>的方式生成对象，改为使用 <code>new SomeClass()</code> 来生成对象</strong>。</p>
<p>ES6 在标准中删除了所有 <code>[[class]]</code> 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。</p>
<p>有了 class 后，JavaScript 就和 Java 很像了。</p>
<p>由于原本的 function 同时承担了定义函数和定义对象的责任，所以现在有些激进的观点：<br><strong>舍弃 function</strong></p>
<ol>
<li>定义函数：使用箭头函数</li>
<li>定义对象：使用 class</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height; <span class="comment">// 当创建对象后，对应对象的数据属性</span></span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getter 当创建对象后，对应对象的访问器 getter 属性</span></span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calcArea();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Method  当创建对象后，对应对象的方法属性</span></span><br><span class="line">  calcArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">100</span>); <span class="comment">// 创建 Rectangle 对象 r</span></span><br><span class="line">r.area; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>而且，ES6 引进 class 后还有了类继承的概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" makes a noise."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name); <span class="comment">// call the super class constructor and pass in the name parameter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" barks."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">"Mitzie"</span>);</span><br><span class="line">d.speak(); <span class="comment">// Mitzie barks.</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/JavaScript/class-prototype.png" alt="class-prototype"></p>
<h2 id="对象根据来源分类-宿主对象和内置对象"><a href="#对象根据来源分类-宿主对象和内置对象" class="headerlink" title="对象根据来源分类-宿主对象和内置对象"></a>对象根据来源分类-宿主对象和内置对象</h2><h3 id="宿主对象-host-Objects"><a href="#宿主对象-host-Objects" class="headerlink" title="宿主对象(host Objects)"></a>宿主对象(host Objects)</h3><p>宿主对象就是 JavaScript 宿主环境提供的对象。如浏览器的 window，node 的 global。全局对象 window 的属性一部分来自浏览器环境，一部分来自 JavaScript 语言。</p>
<h3 id="内置对象-Built-in-Objects"><a href="#内置对象-Built-in-Objects" class="headerlink" title="内置对象(Built-in Objects)"></a>内置对象(Built-in Objects)</h3><p>内置对象就是 JavaScript 语言提供的对象。内置对象分为：</p>
<ul>
<li>固有对象(Intrinsic Objects)：由标准规定，随着 JavaScript 运行而自动创建的对象实例。固有对象在任何 JavaScript 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。如 <code>Array</code> 等。</li>
<li>原生对象(Native Objects)：用户通过 <code>Array</code> 、 <code>RegExp</code> 等内置构造器或者特殊语法创建的对象。</li>
<li>普通对象(Ordinary Objects)：由{}语法、Object 构造器或者 class 关键字创建的对象，这些对象能够被原型继承。</li>
</ul>
<h4 id="原生对象"><a href="#原生对象" class="headerlink" title="原生对象"></a>原生对象</h4><p><img src="/images/JavaScript/built-in-object.png" alt="built-in-object.png"></p>
<p>以上使用 <code>new 构造器</code>创建出的新的对象就是原生对象。几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。这些新创建的对象就是原生对象。</p>
<p>这些使用构造器创建的对象多数使用了私有字段, 例如：</p>
<ul>
<li>Error: <code>[[ErrorData]]</code></li>
<li>Boolean: <code>[[BooleanData]]</code></li>
<li>Number: <code>[[NumberData]]</code></li>
<li>Date: <code>[[DateValue]]</code></li>
<li>RegExp: <code>[[RegExpMatcher]]</code></li>
<li>Symbol: <code>[[SymbolData]]</code></li>
<li>Map: <code>[[MapData]]</code></li>
</ul>
<p>这些私有字段使得原型继承方法无法正常工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b 没法使用原型链</span></span><br><span class="line"><span class="built_in">Array</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Array</span>.sayHi(); <span class="comment">// hi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype; <span class="comment">// true</span></span><br><span class="line">b.sayHi();</span><br><span class="line"><span class="comment">// VM1340:1 Uncaught TypeError: b.sayHi is not a function</span></span><br><span class="line"><span class="comment">//  at &lt;anonymous&gt;:1:3</span></span><br></pre></td></tr></table></figure>

<p>所以我们可以认为，所有这些创建的原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。</p>
<h2 id="用对象来模拟函数与构造器：函数对象与构造器对象"><a href="#用对象来模拟函数与构造器：函数对象与构造器对象" class="headerlink" title="用对象来模拟函数与构造器：函数对象与构造器对象"></a>用对象来模拟函数与构造器：函数对象与构造器对象</h2><p>JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。</p>
<ul>
<li><p><strong>函数对象</strong>的定义是具有 <code>[[call]]</code> 私有字段的对象。</p>
</li>
<li><p><strong>构造器对象</strong>的定义是具有 <code>[[construct]]</code> 私有字段的对象。</p>
</li>
</ul>
<p>JavaScript 中用对象模拟函数和构造器的设计方式代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有 <code>[[call]]</code> 私有字段的对象”，就可以被 JavaScript 函数调用语法支持。<code>[[call]]</code> 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换</p>
<p>我们可以这样说，任何对象只需要实现 <code>[[call]]</code>，它就是一个函数对象，可以去作为函数被调用。</p>
<p>而如果它能实现 <code>[[construct]]</code>，它就是一个构造器对象，可以作为构造器被 new 调用。</p>
<p>对于为 JavaScript 提供运行环境的程序员来说，只要字段符合，就能用对象模拟函数和构造器：</p>
<ul>
<li><p>对于宿主和内置对象来说，它们实现 <code>[[call]]</code>（作为函数被调用）和 <code>[[construct]]</code>（作为构造器被调用）不总是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于用户使用 function 语法或者 Function 构造器创建的对象来说，<code>[[call]]</code> 和 <code>[[construct]]</code> 行为总是相似的。</p>
<p>用户用 <strong>function 语法定义函数就是同时定义了函数对象和构造器对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v = f(); <span class="comment">// 把 f 作为函数调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> f(); <span class="comment">// 把 f 作为构造器调用</span></span><br><span class="line">v; <span class="comment">// 1</span></span><br><span class="line">o.__proto__ === f.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>[[call]]</code> 的执行过程就是执行函数。</p>
<p><code>[[construct]]</code> 的执行过程如下：</p>
<ul>
<li>以 <code>Object.protoype</code> 为原型创建一个新对象</li>
<li>以新对象为 this，执行函数的 <code>[[call]]</code></li>
<li>如果 <code>[[call]]</code> 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象</li>
</ul>
</li>
<li><p>ES6 之后，<code>()=&gt;{}</code> 箭头函数写法，只能作为函数对象，无法作为构造器对象。</p>
</li>
</ul>
<h2 id="创建对象的方式总结"><a href="#创建对象的方式总结" class="headerlink" title="创建对象的方式总结"></a>创建对象的方式总结</h2><ul>
<li><p>new: <code>var a = new Object();</code></p>
</li>
<li><p>字面量: <code>var a = {};</code></p>
</li>
<li><p>function: <code>var o = function(){};</code></p>
</li>
<li><p>DOM API: <code>var a = document.createElement(&#39;p&#39;);</code></p>
</li>
<li><p>内置对象 API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">Object</span>.assign(&#123; <span class="attr">k1</span>: <span class="number">3</span>, <span class="attr">k2</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">k3</span>: <span class="number">9</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> g = <span class="built_in">JSON</span>.parse(<span class="string">"&#123;&#125;"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>装箱：<code>var a = Object(true);</code></p>
</li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/前端/" rel="tag"># 前端</a>
            
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
            
              <a href="/tags/Object/" rel="tag"># Object</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/11/27/JavaScript-运行时-Symbol/" rel="next" title="JavaScript Symbol">
                  <i class="fa fa-chevron-left"></i> JavaScript Symbol
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/11/27/JavaScript-运行时-HandleBigIntinJavaScript/" rel="prev" title="Handle Big Int in JavaScript">
                  Handle Big Int in JavaScript <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据属性和访问器属性-getter-setter"><span class="nav-number">1.</span> <span class="nav-text">数据属性和访问器属性(getter/setter)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据属性"><span class="nav-number">1.1.</span> <span class="nav-text">数据属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问器属性"><span class="nav-number">1.2.</span> <span class="nav-text">访问器属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型"><span class="nav-number">2.</span> <span class="nav-text">原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#prototype-VS-proto-VS-prototype"><span class="nav-number">2.1.</span> <span class="nav-text">[[prototype]] VS __proto__ VS prototype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作对象原型的方法"><span class="nav-number">2.2.</span> <span class="nav-text">操作对象原型的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-create"><span class="nav-number">2.2.1.</span> <span class="nav-text">Object.create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-操作符"><span class="nav-number">2.2.2.</span> <span class="nav-text">new 操作符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-中引入的-class，使“类”的思想设计代码更清晰"><span class="nav-number">3.</span> <span class="nav-text">ES6 中引入的 class，使“类”的思想设计代码更清晰</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象根据来源分类-宿主对象和内置对象"><span class="nav-number">4.</span> <span class="nav-text">对象根据来源分类-宿主对象和内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#宿主对象-host-Objects"><span class="nav-number">4.1.</span> <span class="nav-text">宿主对象(host Objects)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置对象-Built-in-Objects"><span class="nav-number">4.2.</span> <span class="nav-text">内置对象(Built-in Objects)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原生对象"><span class="nav-number">4.2.1.</span> <span class="nav-text">原生对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用对象来模拟函数与构造器：函数对象与构造器对象"><span class="nav-number">5.</span> <span class="nav-text">用对象来模拟函数与构造器：函数对象与构造器对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建对象的方式总结"><span class="nav-number">6.</span> <span class="nav-text">创建对象的方式总结</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Frank Hu</p>
  <div class="site-description" itemprop="description">Developer, Juventino</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frank Hu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
